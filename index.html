<!DOCTYPE html>
<html>
<head>
    <title>Get dunked on loser</title>
</head>
<body>
<div class="tip" markdown="1">
    # SYSC 3020 Lecture 2

### Complex systems are complex (who would have figured right?)

* Complex systems are hard to understand
  * The 7 + / - phenomena
* Modeling and abstraction!

### Software engineering is modeling
* A model is an abstraction of a system
  *  A system that no longer exists
  *  An existing system
  *  A future system to be built

### Using Models to describe Software systems
* **Object model**: What is the structure of the system?
* **Functional model**: What are the functions of the system?
* **Dynamic model**: How does the system react to external events?

**System model:** Object model + functional model + dynamic model

### Software engineering is problem solving
- Analysis
  - Understanding the nature of the problem and break the problem into pieces
- Synthesis
  - Put the pieces together into a large structure

For problem solving, we use techniques, methodologies, and tools.

### Software engineering is Knowledge acquisition
- Knowledge acquisition is non-linear
- Which software development process to use?
- Anticipate changes and plan accordingly

## Software Engineering [IEEE-93]
>The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software

### Definitions
- Software life cycle
  - Set of activities and their relationships to each other to support the development of a software system
- Software development methodology
  - A collection of techniques for building models applied across a software life cycle.

The term "lifecycle" is based on the metaphor of the life of a person

#### Conception > Childhood > Adulthood > Retirement 
#### Pre-development > Development > Post-development

### Typical SDLC Questions

- *Which activities* should we select for the software project?
- What are teh *dependencies* between activities?
- How should we schedule the *activities*?

- To find these activities and dependencies we can use the same modeling techniques we use for software development:
  - Functional modeling of a software lifecycle
    - Scenarios, use case model
  - Structural modeling of a software lifecycle
    - Object identification, class diagrams
  - Dynamic modeling of a software lifecyle
    - Sequence diagrams, statechart, and activity diagrams

## Identifying software development activities
- **Requirement analysis**: What is the problem?
- **System Design**: What is the solution?
- **Detailed Design**: What are the best mechanisms to implement the solution?
- **Program Implementation**: How is the solution constructed?
- **Testing**: Is the problem solved?
- **Delivery**: Can the customer use the solution? 
- **Maintenance**: How do we deal with changes that occur during the developement? Are enhancements needed?

### Example SLDC models
- Waterfall model
- V-Model
- Spiral Model
- Unified Process
- Agile Process
- Model-based Development Process 
  
## Waterfall model

In principle, a phase should not start until the previous phase has finished

![I still don't know exactly what this does](waterfallmodel.jpg)

Problems:
- Real projects rarely follow the sequential flow
- Difficult for stakeholder to state all the requirements once and for all
- Stakeholders must have patience: working version of software comes late in the process.

## V-Model
Variation of the waterfall model that has very similar weaknesses to it

![V-Model img](vmodel.jpg)

## Properties of Waterfall-based models

Managers love waterfall models!
- Nice milestones
- No need to look back (Linear system)
- Always one activity at a time
- Easy to check progress during development: *"The system is 90% coded", "We have done 20% of our tests"*

However, software development is non-linear
- While a design is being developed, problems with requirements are identified
- While a program is being implemented, design and requirement problems are found
- While a program is being tested, coding errors, design errors and requirement errors are found.

## Spiral Model
Focuses on addressing risks incrementally, in order of priority.

Activities:
- Determine objectives and constraints.
- Evaluate alternatives
- Identify risks
- Resolve risks by assigning priorities to risks
- Develop a series of prototypes for the identified risks starting with the highest risk
- Use a waterfall model for each prototype development
- If a risk has successfully been resolved, evaluate the results of the round and plan the next round
- If a certain risk cannot be resolved, terminate the project immediately

This set of activities is applied to a couple of so-called rounds

## Unified process model
- The unified process model is an iterative process model
- Software has 4 phases:
  - Inception
  - Elaboration
  - Construction
  - Transition
- Several Artifacts sets
  - Management set
  - Engineering set
- Several Workflows (7)
  - Management
  - Environment
  - Requirements
  - Design
  - Implementation
  - Assessment
  - Deployment
- Each iterationis managed as a software project
- Project participants are called stakeholders

## Inception Phase: Objectives
- Establish the project's scope
- Define acceptable criteria
- Identify the critial use cases and scenarios
- Demonstrate at least one candidate software architecture
- Estimate the cost and schedule for the project
- Define and estimate potential risks
- At the end of this phase the "engineering" of the system is complete

## Elaboration Phase
- A decision must be made:
  - Commit to production phase?
  - Move to an operation with higher cost risk and inertia (i.e. bureaucracy)?
- Main Questions:
  - Are the system models and project plans stable enough?
  - Have the risk been dealt with?
  - Can we predict cost and schedule for the completion of the development for an acceptable range?

## Construction Phase
- Minimize development costs by optimizing resourses
  - Avoid unnecessary restarts (modeling, coding) 
- Achieve adequate quality as fast as possible
- Achieve useful version
  - Alpha, beta, and other test releases

## Transition Phase
- Achieve independence of users
- Produce a deployment version that is complete and consistent
- Build a release as rapidly and cost-effective as possible

## Iteration in the Unified process
Each of the four phases consists of one or more iterations
An *iteration* represents a set of activities for which
- Milestones are defined ("a well-defined intermediate event")
- the scope and results are capture with work-products called *artifacts*

## Artifacts Sets in the Unified Process
![](artifacts.jpg)

## Agile Model
### Key assumptions
- Difficult to predict software requirements
- Difficult to predict analysis, design, construction, and testing
- Design and construction should be interleaved

#### How can we Design a process that can manage unpredictability?
- Process adaptability

### Example: Extreme Programming (XP)
- 4 phases: Planning (stories), Design (Prototype solutions), Coding (pair programming, retesting), Test
- The tests are the specification
- Communication paramount (Small team, knowledgeable programmers)

![](dumbfuckingcomparison.jpg)

</div> 
</body>
</html>